.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::BrowserDetect 3"
.TH HTTP::BrowserDetect 3 "2010-05-05" "perl v5.12.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::BrowserDetect \- Determine Web browser, version, and platform from an HTTP user agent string
.SH "VERSION"
.IX Header "VERSION"
Version 1.10
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use HTTP::BrowserDetect;
\&
\&    my $browser = new HTTP::BrowserDetect($user_agent_string);
\&
\&    # Detect operating system
\&    if ($browser\->windows) {
\&      if ($browser\->winnt) ...
\&      if ($browser\->win95) ...
\&    }
\&    print $browser\->mac;
\&
\&    # Detect browser vendor and version
\&    print $browser\->netscape;
\&    print $browser\->ie;
\&    if (browser\->major(4)) {
\&    if ($browser\->minor() > .5) {
\&        ...
\&    }
\&    }
\&    if ($browser\->version() > 4) {
\&      ...;
\&    }
\&
\&    # Process a different user agent string
\&    $browser\->user_agent($another_user_agent_string);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The HTTP::BrowserDetect object does a number of tests on an \s-1HTTP\s0 user agent
string. The results of these tests are available via methods of the object.
.PP
This module is based upon the JavaScript browser detection code available at
\&\fBhttp://www.mozilla.org/docs/web\-developer/sniffer/browser_type.html\fR.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
In most cases, you can just issue the following commands:
.PP
.Vb 4
\&  perl Build.PL
\&  ./Build
\&  ./Build test
\&  ./Build install
.Ve
.PP
Please see the documentation for Module::Build if you have questions about
installing to custom locations etc.
.SH "CONSTRUCTOR AND STARTUP"
.IX Header "CONSTRUCTOR AND STARTUP"
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 1
\&    HTTP::BrowserDetect\->new( $user_agent_string )
.Ve
.PP
The constructor may be called with a user agent string specified. Otherwise,
it will use the value specified by \f(CW$ENV\fR{'\s-1HTTP_USER_AGENT\s0'}, which is set by
the web server when calling a \s-1CGI\s0 script.
.PP
You may also use a non-object-oriented interface. For each method, you may
call \fIHTTP::BrowserDetect::method_name()\fR. You will then be working with a
default HTTP::BrowserDetect object that is created behind the scenes.
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "user_agent($user_agent_string)"
.IX Subsection "user_agent($user_agent_string)"
Returns the value of the user agent string. When called with a parameter, it
resets the user agent and reperforms all tests on the string. This way you can
process a series of user agent strings (from a log file, perhaps) without
creating a new HTTP::BrowserDetect object each time.
.SS "\fIcountry()\fP"
.IX Subsection "country()"
Returns the country string as it may be found in the user agent string. This
will be in the form of an upper case 2 character code. ie: \s-1US\s0, \s-1DE\s0, etc
.SS "\fIlanguage()\fP"
.IX Subsection "language()"
Returns the language string as it is found in the user agent string. This will
be in the form of an upper case 2 character code. ie: \s-1EN\s0, \s-1DE\s0, etc
.SS "\fIdevice()\fP"
.IX Subsection "device()"
Returns the method name of the actual hardware, if it can be detected.
Currently returns one of: blackberry, iphone, ipod or ipad  Returns \s-1UNDEF\s0 if
no hardware can be detected
.SS "\fIdevice_name()\fP"
.IX Subsection "device_name()"
Returns a human formatted version of the hardware device name.  These names
are subject to change and are really meant for display purposes.  You should
use the \fIdevice()\fR method in your logic.  Returns one of: BlackBerry, iPhone,
iPod or iPad.  Returns \s-1UNDEF\s0 if no hardware can be detected.
.SH "Detecting Browser Version"
.IX Header "Detecting Browser Version"
Please note that that the \fIversion()\fR, \fImajor()\fR and \fIminor()\fR methods have been
superceded as of release 1.07 of this module. They are not yet deprecated, but
should be replaced with \fIpublic_version()\fR, \fIpublic_major()\fR and \fIpublic_minor()\fR in
new development.
.PP
The reasoning behind this is that \fIversion()\fR method will, in the case of
Safari, return the Safari/XXX numbers even when Version/XXX numbers are
present in the UserAgent string. Because this behaviour has been in place for
so long, some clients may have come to rely upon it. So, it has been retained
in the interest of \*(L"bugwards compatibility\*(R", but in almost all cases, the
numbers returned by \fIpublic_version()\fR, \fIpublic_major()\fR and \fIpublic_minor()\fR will
be what you are looking for.
.SS "\fIpublic_version()\fP"
.IX Subsection "public_version()"
Returns the browser version as a floating-point number.
.SS "\fIpublic_major()\fP"
.IX Subsection "public_major()"
Returns the integer portion of the browser version.
.SS "\fIpublic_minor()\fP"
.IX Subsection "public_minor()"
Returns the decimal portion of the browser version as a \fBfloating-point
number\fR less than 1. For example, if the version is 4.05, this method returns
\&.05; if the version is 4.5, this method returns .5.
.PP
On occasion a version may have more than one decimal point, such as
\&'Wget/1.4.5'. The minor version does not include the second decimal point, or
any further digits or decimals.
.SS "version($version)"
.IX Subsection "version($version)"
Returns the version as a floating-point number. If passed a parameter, returns
true if it is equal to the version specified by the user agent string.
.SS "major($major)"
.IX Subsection "major($major)"
Returns the integer portion of the browser version. If passed a parameter,
returns true if it equals the browser major version.
.SS "minor($minor)"
.IX Subsection "minor($minor)"
Returns the decimal portion of the browser version as a \fBfloating-point
number\fR less than 1. For example, if the version is 4.05, this method returns
\&.05; if the version is 4.5, this method returns .5. \fBThis is a change in
behavior from previous versions of this module, which returned a string\fR.
.PP
If passed a parameter, returns true if equals the minor version.
.PP
On occasion a version may have more than one decimal point, such as
\&'Wget/1.4.5'. The minor version does not include the second decimal point, or
any further digits or decimals.
.SS "beta($beta)"
.IX Subsection "beta($beta)"
Returns any the beta version, consisting of any non-numeric characters after
the version number. For instance, if the user agent string is 'Mozilla/4.0
(compatible; \s-1MSIE\s0 5.0b2; Windows \s-1NT\s0)', returns 'b2'. If passed a parameter,
returns true if equal to the beta version. If the beta starts with a dot, it
is thrown away.
.SH "Detecting Rendering Engine"
.IX Header "Detecting Rendering Engine"
.SS "\fIengine_string()\fP"
.IX Subsection "engine_string()"
Returns one of the following:
.PP
Gecko, \s-1KHTML\s0, \s-1MSIE\s0
.PP
Returns undef if no string can be found.
.SS "\fIengine_version()\fP"
.IX Subsection "engine_version()"
Returns the version number of the rendering engine. Currently this only
returns a version number for Gecko. Returns undef for all other engines.
.SS "\fIengine_major()\fP"
.IX Subsection "engine_major()"
Returns the major version number of the rendering engine. Currently this only
returns a version number for Gecko. Returns undef for all other engines.
.SS "\fIengine_minor()\fP"
.IX Subsection "engine_minor()"
Returns the minor version number of the rendering engine. Currently this only
returns a version number for Gecko. Returns undef for all other engines.
.SH "Detecting OS Platform and Version"
.IX Header "Detecting OS Platform and Version"
The following methods are available, each returning a true or false value.
Some methods also test for the operating system version. The indentations
below show the hierarchy of tests (for example, win2k is considered a type of
winnt, which is a type of win32)
.SS "\fIwindows()\fP"
.IX Subsection "windows()"
.Vb 5
\&    win16 win3x win31
\&    win32
\&        winme win95 win98
\&        winnt
\&            win2k winxp win2k3 winvista win7
.Ve
.SS "\fIdotnet()\fP"
.IX Subsection "dotnet()"
.SS "\fImac()\fP"
.IX Subsection "mac()"
mac68k macppc macosx
.SS "\fIos2()\fP"
.IX Subsection "os2()"
.SS "\fIunix()\fP"
.IX Subsection "unix()"
.Vb 3
\&  sun sun4 sun5 suni86 irix irix5 irix6 hpux hpux9 hpux10
\&  aix aix1 aix2 aix3 aix4 linux sco unixware mpras reliant
\&  dec sinix freebsd bsd
.Ve
.SS "\fIvms()\fP"
.IX Subsection "vms()"
.SS "\fIamiga()\fP"
.IX Subsection "amiga()"
It may not be possibile to detect Win98 in Netscape 4.x and earlier. On Opera
3.0, the userAgent string includes \*(L"Windows 95/NT4\*(R" on all Win32, so you can't
distinguish between Win95 and WinNT.
.SS "\fIos_string()\fP"
.IX Subsection "os_string()"
Returns one of the following strings, or undef. This method exists solely for
compatibility with the HTTP::Headers::UserAgent module.
.PP
.Vb 2
\&  Win95, Win98, WinNT, Win2K, WinXP, Win2K3, WinVista, Win7, Mac, Mac OS X,
\&  Win3x, OS2, Unix, Linux
.Ve
.SH "Detecting Browser Vendor"
.IX Header "Detecting Browser Vendor"
The following methods are available, each returning a true or false value.
Some methods also test for the browser version, saving you from checking the
version separately.
.PP
\fInetscape nav2 nav3 nav4 nav4up nav45 nav45up navgold nav6 nav6up\fR
.IX Subsection "netscape nav2 nav3 nav4 nav4up nav45 nav45up navgold nav6 nav6up"
.PP
\fIgecko\fR
.IX Subsection "gecko"
.PP
\fImozilla\fR
.IX Subsection "mozilla"
.PP
\fIfirefox\fR
.IX Subsection "firefox"
.PP
\fIsafari\fR
.IX Subsection "safari"
.PP
\fIchrome\fR
.IX Subsection "chrome"
.PP
\fIie ie3 ie4 ie4up ie5 ie55 ie6 ie7 ie8\fR
.IX Subsection "ie ie3 ie4 ie4up ie5 ie55 ie6 ie7 ie8"
.PP
\fIneoplanet neoplanet2\fR
.IX Subsection "neoplanet neoplanet2"
.PP
\fImosaic\fR
.IX Subsection "mosaic"
.PP
\fIaol aol3 aol4 aol5 aol6\fR
.IX Subsection "aol aol3 aol4 aol5 aol6"
.PP
\fIwebtv\fR
.IX Subsection "webtv"
.PP
\fIopera opera3 opera4 opera5 opera6 opera7\fR
.IX Subsection "opera opera3 opera4 opera5 opera6 opera7"
.PP
\fIlynx links\fR
.IX Subsection "lynx links"
.PP
\fIemacs\fR
.IX Subsection "emacs"
.PP
\fIstaroffice\fR
.IX Subsection "staroffice"
.PP
\fIlotusnotes\fR
.IX Subsection "lotusnotes"
.PP
\fIicab\fR
.IX Subsection "icab"
.PP
\fIkonqueror\fR
.IX Subsection "konqueror"
.PP
\fIjava\fR
.IX Subsection "java"
.PP
\fIcurl\fR
.IX Subsection "curl"
.PP
\fIrealplayer\fR
.IX Subsection "realplayer"
.PP
Netscape 6, even though its called six, in the userAgent string has version
number 5. The nav6 and nav6up methods correctly handle this quirk. The firefox
text correctly detects the older-named versions of the browser (Phoenix,
Firebird)
.SS "\fIbrowser_string()\fP"
.IX Subsection "browser_string()"
Returns undef on failure.  Otherwise returns one of the following:
.PP
Firefox, Safari, Chrome, \s-1MSIE\s0, etc
.PP
To see a complete list of possible browser strings, check the \fIbrowser_string()\fR
method in the source code.
.SS "\fIgecko_version()\fP"
.IX Subsection "gecko_version()"
If a Gecko rendering engine is used (as in Mozilla or Firebird), returns the
version of the renderer (e.g. 1.3a, 1.7, 1.8) This might be more useful than
the particular browser name or version when correcting for quirks in different
versions of this rendering engine. If no Gecko browser is being used, or the
version number can't be detected, returns undef.
.SH "Detecting Other Devices"
.IX Header "Detecting Other Devices"
The following methods are available, each returning a true or false value.
.PP
\fIandroid\fR
.IX Subsection "android"
.PP
\fIaudrey\fR
.IX Subsection "audrey"
.PP
\fIavantgo\fR
.IX Subsection "avantgo"
.PP
\fIblackberry\fR
.IX Subsection "blackberry"
.PP
\fIiopener\fR
.IX Subsection "iopener"
.PP
\fIiphone\fR
.IX Subsection "iphone"
.PP
\fIipod\fR
.IX Subsection "ipod"
.PP
\fIipad\fR
.IX Subsection "ipad"
.PP
\fIpalm\fR
.IX Subsection "palm"
.PP
\fIwap\fR
.IX Subsection "wap"
.SS "\fImobile()\fP"
.IX Subsection "mobile()"
Returns true if the browser appears to belong to a handheld device.
.SS "\fIrobot()\fP"
.IX Subsection "robot()"
Returns true if the user agent appears to be a robot, spider, crawler, or
other automated Web client.
.PP
The following additional methods are available, each returning a true or false
value. This is by no means a complete list of robots that exist on the Web.
.PP
\fIwget\fR
.IX Subsection "wget"
.PP
\fIgetright\fR
.IX Subsection "getright"
.PP
\fIyahoo\fR
.IX Subsection "yahoo"
.PP
\fIaltavista\fR
.IX Subsection "altavista"
.PP
\fIlycos\fR
.IX Subsection "lycos"
.PP
\fIinfoseek\fR
.IX Subsection "infoseek"
.PP
\fIlwp\fR
.IX Subsection "lwp"
.PP
\fIwebcrawler\fR
.IX Subsection "webcrawler"
.PP
\fIlinkexchange\fR
.IX Subsection "linkexchange"
.PP
\fIslurp\fR
.IX Subsection "slurp"
.PP
\fIgoogle\fR
.IX Subsection "google"
.PP
\fIpuf\fR
.IX Subsection "puf"
.SH "AUTHOR"
.IX Header "AUTHOR"
Lee Semel, lee@semel.net (Original Author)
.PP
Peter Walsham (co-maintainer)
.PP
Olaf Alders, \f(CW\*(C`olaf at wundercounter.com\*(C'\fR (co-maintainer)
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to the following for their contributions:
.PP
Leonardo Herrera
.PP
Denis F. Latypoff
.PP
merlynkline
.PP
Simon Waters
.PP
Toni Cebrin
.PP
Florian Merges
.PP
david.hilton.p
.PP
Steve Purkis
.PP
Andrew McGregor
.PP
Robin Smidsrod
.PP
Richard Noble
.PP
Josh Ritter
.PP
Mike Clarke
.PP
Marc Sebastian Pelzer
.PP
Alexey Surikov
.PP
Maros Kollar
.PP
Jay Rifkin
.SH "TO DO"
.IX Header "TO DO"
The \fI_engine()\fR method currently only handles Gecko.  It needs to be expanded to
handle other rendering engines.
.PP
\&\s-1POD\s0 coverage is also not 100%.
.PP
If you're able to help out with anything on the \s-1TO\s0 \s-1DO\s0 list, please do. A great
deal of the latest improvements have come from patches via \s-1RT\s0 and GitHub pull
requests. If you're able to submit changes via GitHub, I'm generally able to
get them into a new release fairly quickly.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"The Ultimate JavaScript Client Sniffer, Version 3.0\*(R", \fBhttp://www.mozilla.org/docs/web\-developer/sniffer/browser_type.html\fR.
.PP
\&\*(L"Browser \s-1ID\s0 (User-Agent) Strings\*(R" \fBhttp://www.zytrax.com/tech/web/browser_ids.htm\fR
.PP
\&\fIperl\fR\|(1), HTTP::Headers, HTTP::Headers::UserAgent.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc HTTP::BrowserDetect
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
GitHub Source Repository
.Sp
http://github.com/oalders/http\-browserdetect <http://github.com/oalders/http-browserdetect>
.IP "\(bu" 4
\&\s-1RT:\s0 \s-1CPAN\s0's request tracker
.Sp
http://rt.cpan.org/NoAuth/Bugs.html?Dist=HTTP\-BrowserDetect <http://rt.cpan.org/NoAuth/Bugs.html?Dist=HTTP-BrowserDetect>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
http://annocpan.org/dist/HTTP\-BrowserDetect <http://annocpan.org/dist/HTTP-BrowserDetect>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
http://cpanratings.perl.org/d/HTTP\-BrowserDetect <http://cpanratings.perl.org/d/HTTP-BrowserDetect>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
http://search.cpan.org/dist/HTTP\-BrowserDetect/ <http://search.cpan.org/dist/HTTP-BrowserDetect/>
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
The biggest limitation at this point is the test suite, which really needs to
have many more UserAgent strings to test against.
.PP
Patches are certainly welcome, with many thanks to the many contributions
which have already been received. The preferred method of patching would be to
fork the GitHub repo and then send me a pull requests, but plain old patch
files are also welcome.
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 1999\-2010 Lee Semel. All rights reserved. This program is free
software; you can redistribute it and/or modify it under the same terms as
Perl itself.
